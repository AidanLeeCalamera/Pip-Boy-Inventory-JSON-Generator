<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Items.json Generator</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
	<script src="presets_consumables.js"></script>
	<script src="presets_weapons.js"></script>
	<script src="presets_apparel.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
	<script src="EspruinoWebTools/uart.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background: #3a3a3a;
			min-height: 100vh;
			color: #e0e0e0;
		}

		.container {
			background: #2b2b2b;
			height: 100vh;
			display: flex;
			flex-direction: column;
		}

		.header {
			background: #1f1f1f;
			color: #e0e0e0;
			padding: 15px 30px;
			text-align: center;
			border-bottom: 3px solid #555;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.header-buttons {
			display: flex;
			gap: 10px;
		}

		.header h1 {
			font-size: 1.5em;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
			margin: 0;
		}

		.export-btn-header {
			background: #666;
			color: white;
			border: none;
			padding: 12px 30px;
			border-radius: 6px;
			font-size: 1em;
			font-weight: 600;
			cursor: pointer;
			transition: background 0.3s;
		}

		.export-btn-header:hover {
			background: #777;
		}

		.export-btn-header:disabled {
			background: #444;
			color: #888;
			cursor: not-allowed;
		}

        #btnLoadFromDevice {
            width: auto;
            padding: 12px 20px;
        }


		.main-content {
			display: grid;
			grid-template-columns: 308px 1fr 306px;
			gap: 0;
			flex-grow: 1;
			overflow: hidden;
		}

		.sidebar {
			background: #353535;
			border-right: 2px solid #555;
			padding: 15px;
			overflow-y: auto;
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		.item-list {
			list-style: none;
			flex-grow: 1;
			overflow-y: auto;
			margin-bottom: 12px;
		}

		.item-list li {
			background: #2b2b2b;
			margin-bottom: 6px;
			padding: 10px;
			border-radius: 6px;
			cursor: pointer;
			border: 2px solid transparent;
			transition: all 0.2s;
			display: flex;
			justify-content: space-between;
			align-items: center;
			color: #e0e0e0;
		}

		.item-list li:hover {
			border-color: #666;
			background: #3a3a3a;
		}

		.item-list li.active {
			background: #555;
			color: white;
			border-color: #777;
		}

		.item-name-wrapper {
			display: flex;
			flex-direction: column;
			flex: 1;
		}

		.item-name {
			font-weight: 600;
		}

		.item-type {
			font-size: 0.75em;
			padding: 2px 8px;
			border-radius: 10px;
			background: #4a4a4a;
			margin-left: 8px;
		}

		.item-list li.active .item-type {
			background: rgba(255, 255, 255, 0.3);
		}

		.delete-btn {
			background: #f44336;
			color: white;
			border: none;
			padding: 4px 8px;
			border-radius: 4px;
			cursor: pointer;
			margin-left: 8px;
			font-size: 0.85em;
		}

		.delete-btn:hover {
			background: #da190b;
		}

		.add-item-btn {
			width: 100%;
			padding: 10px;
			background: #555;
			color: white;
			border: none;
			border-radius: 6px;
			font-size: 0.95em;
			font-weight: 600;
			cursor: pointer;
			margin-bottom: 8px;
			transition: background 0.3s;
			flex-shrink: 0;
		}

		.add-item-btn:hover {
			background: #666;
		}

		.preset-dropdown {
			width: 100%;
			padding: 8px;
			background: #3a3a3a;
			color: #e0e0e0;
			border: 2px solid #555;
			border-radius: 6px;
			font-size: 0.9em;
			cursor: pointer;
			margin-bottom: 12px;
			flex-shrink: 0;
		}

		.preset-dropdown:hover {
			border-color: #777;
		}

		.editor {
			padding: 20px;
			overflow-y: auto;
			height: 100%;
			border-right: 2px solid #555;
		}

		.form-group {
			margin-bottom: 12px;
		}

		.form-row {
			display: grid;
			grid-template-columns: 1fr 2fr;
			gap: 12px;
			margin-bottom: 12px;
		}

		label {
			display: block;
			font-weight: 600;
			margin-bottom: 4px;
			color: #c0c0c0;
			font-size: 0.85em;
		}

		input[type="text"],
		input[type="number"],
		textarea,
		select {
			width: 100%;
			padding: 7px;
			border: 2px solid #555;
			border-radius: 6px;
			font-size: 0.9em;
			transition: border-color 0.3s;
			background: #3a3a3a;
			color: #e0e0e0;
		}

		input:focus,
		textarea:focus,
		select:focus {
			outline: none;
			border-color: #777;
		}

		textarea {
			resize: vertical;
			min-height: 50px;
			font-family: inherit;
		}

		.stats-container,
		.damages-container,
		.defenses-container {
			background: #353535;
			padding: 10px;
			border-radius: 6px;
			margin-top: 6px;
		}

		.stat-item {
			display: grid;
			grid-template-columns: 1fr 1fr auto auto;
			gap: 6px;
			margin-bottom: 6px;
			align-items: end;
		}

		.stat-item.consumable-stat {
			grid-template-columns: 1fr 1fr auto auto auto;
		}

		.damage-item,
		.defense-item {
			display: grid;
			grid-template-columns: 1fr 1fr auto;
			gap: 6px;
			margin-bottom: 6px;
			align-items: end;
		}

		.remove-stat-btn {
			background: #f44336;
			color: white;
			border: none;
			padding: 7px 10px;
			border-radius: 6px;
			cursor: pointer;
			font-size: 0.8em;
		}

		.add-stat-btn {
			background: #555;
			color: white;
			border: none;
			padding: 5px 10px;
			border-radius: 6px;
			cursor: pointer;
			margin-top: 6px;
			font-size: 0.8em;
		}

		.add-stat-btn:hover {
			background: #666;
		}

		.checkbox-group {
			display: flex;
			align-items: center;
			margin-top: 10px;
		}

		.checkbox-group input[type="checkbox"] {
			width: auto;
			margin-right: 8px;
		}

		.sound-list,
		.equip-slot-list {
			display: flex;
			flex-wrap: wrap;
			gap: 6px;
			margin-top: 6px;
		}

		.sound-tag,
		.equip-slot-tag {
			background: #555;
			color: white;
			padding: 4px 10px;
			border-radius: 15px;
			font-size: 0.8em;
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.sound-tag button,
		.equip-slot-tag button {
			background: rgba(255, 255, 255, 0.3);
			border: none;
			color: white;
			border-radius: 50%;
			width: 18px;
			height: 18px;
			cursor: pointer;
			font-weight: bold;
			font-size: 0.8em;
		}

		.empty-state {
			text-align: center;
			padding: 60px 20px;
			color: #888;
		}

		.empty-state h2 {
			margin-bottom: 15px;
		}

		.section-header {
			font-size: 1.1em;
			color: #e0e0e0;
			margin-bottom: 12px;
			padding-bottom: 6px;
			border-bottom: 2px solid #555;
		}

		.pipboy-preview-container {
			background: #000;
			color: #14ff72;
			padding: 15px;
			font-family: 'VT323', monospace;
			font-size: 20px;
			height: 100%;
			overflow-y: auto;
		}

		.preview-header {
			display: flex;
			justify-content: space-between;
			border-bottom: 2px solid #14ff72;
			padding-bottom: 5px;
			margin-bottom: 5px;
		}

		.preview-stats-list .stat-row {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 2px 4px;
			margin-bottom: 2px;
			height: 24px;
		}

		.preview-stats-list .stat-row .stat-name,
		.preview-stats-list .stat-row .stat-value {
			display: flex;
			align-items: center;
			gap: 6px;
		}

		.preview-stats-list .bright-bg {
			background-color: #0d3a1f;
		}

		.preview-stats-list .dithered-bg {
			background-image: repeating-linear-gradient(#000 0, #000 1px, #0a2815 1px, #0a2815 2px);
		}

		.reorder-arrows {
			display: flex;
			flex-direction: column;
			gap: 2px;
		}

		.reorder-arrows button {
			background: #555;
			color: white;
			border: none;
			border-radius: 4px;
			width: 20px;
			height: 15px;
			line-height: 15px;
			cursor: pointer;
			font-size: 10px;
		}

		.reorder-arrows button:hover {
			background: #666;
		}

		.reorder-arrows button:disabled {
			background: #444;
			color: #888;
			cursor: not-allowed;
		}

		hr {
			border: 1px solid #555;
			margin: 12px 0;
			flex-shrink: 0;
			width: 100%;
		}

		.base-item-controls {
			display: flex;
			gap: 8px;
			flex-shrink: 0;
		}

		.add-base-btn {
			flex: 1;
			padding: 8px;
			font-size: 0.85em;
			background: #555;
			color: white;
			border: none;
			border-radius: 6px;
			font-weight: 600;
			cursor: pointer;
			transition: background 0.3s;
		}

		.add-base-btn:hover {
			background: #666;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="header">
			<h1>Items.json Generator</h1>
			<div class="header-buttons">
				<button id="btnConnectUSB" class="export-btn-header">Connect via USB</button>
				<button id="btnUploadUSB" class="export-btn-header" onclick="sendJSONviaUSB()" disabled>Upload to Device</button>
				<button id="exportBtnHeader" class="export-btn-header" onclick="exportJSON()" disabled>Download Items As ZIP</button>
			</div>
		</div>

		<div class="main-content">
			<div class="sidebar">
				<button id="btnLoadFromDevice" class="add-item-btn export-btn-header" onclick="loadItemsFromDevice()" style="width:auto;">Load Items from Device</button>
				
				<button class="add-item-btn" onclick="document.getElementById('fileInput').click()">Load Items JSONs...</button>
				<input type="file" id="fileInput" multiple accept=".json" style="display: none;" onchange="loadItemsFromFiles(event)">

				<button class="add-item-btn" onclick="document.getElementById('folderInput').click()">Select DATA Folder</button>
				<input type="file" id="folderInput" webkitdirectory directory style="display: none;" onchange="loadDataFolder(event)">

				<select class="preset-dropdown" id="presetDropdown" onchange="addPresetItem(this.value); this.value='';"></select>

				<ul class="item-list" id="itemList"></ul>

				<hr>
				<div class="base-item-controls">
					<button class="add-base-btn" onclick="addBaseItem('weapon')">+Base Weapon</button>
					<button class="add-base-btn" onclick="addBaseItem('apparel')">+Base Apparel</button>
					<button class="add-base-btn" onclick="addBaseItem('consumable')">+Base Consumable</button>
				</div>
			</div>

			<div class="editor" id="editor">
				<div class="empty-state">
					<h2>No item selected</h2>
					<p>Select an item from the list or create a new one</p>
				</div>
			</div>

			<div class="pipboy-preview-container" id="pipboy-preview">
				<div class="preview-header"> <span id="preview-name">ITEM NAME</span><span>QTY <span id="preview-qty">0</span></span></div>
				<div class="preview-stats-list" id="preview-stats-list"></div>
			</div>
		</div>
	</div>

	<script>
		let items = [];
		let currentIndex = -1;
		let availableSounds = [];
		let availableImages = [];
		let presetItems = {};

		const damageTypes = ["attack", "energy", "fire", "frost", "bleed", "rad"];
		const defenseTypes = ["defense", "energy", "fire", "frost", "rad"];
		const apparelEquipSlots = ["hat", "eyewear", "mask", "clothing", "chest", "leftArm", "rightArm", "leftLeg", "rightLeg", "accessory"];


		// --- Upload Function ---
		function sendJSONviaUSB() {
			if (!UART.isConnected()) {
				alert("Please connect to a USB device first.");
				return;
			}

			// Disable button during upload
			const uploadBtn = document.getElementById('btnUploadUSB');
			uploadBtn.disabled = true;
			uploadBtn.textContent = "Uploading...";

			console.log("Cleaning up old item files on device...");

			// Original, simpler cleanup code
			const cleanupCode = `
				var fs = require('fs');
				var files = fs.readdirSync('DATA'); // Read DATA dir
				files.forEach(function(f) {
				  // Delete items_X.json files within DATA
				  if (f.startsWith('items_') && f.endsWith('.json')) {
					try { fs.unlink('DATA/' + f); console.log('Deleted DATA/'+f); } catch(e) { console.log('Error deleting DATA/'+f, e); }
				  }
				});
				// Delete items_meta.json within DATA
				if (files.includes('items_meta.json')) {
				  try { fs.unlink('DATA/items_meta.json'); console.log('Deleted DATA/items_meta.json'); } catch(e) { console.log('Error deleting DATA/items_meta.json', e); }
				}
				print('CLEANUP_DONE');
			`;

            // We need a way to know cleanup is done. We'll use a simple delay and hope for the best,
            // as the Promise logic was causing timeouts. This is less reliable but avoids the timeout.
            let cleanupSent = false;
            let cleanupConfirmed = false; // Flag to prevent multiple uploads

            function onDataCleanup(data) {
                 console.log("Cleanup Recv: " + data);
                 if (data.includes('CLEANUP_DONE') && !cleanupConfirmed) {
                    cleanupConfirmed = true; // Mark as confirmed
                    console.log("Cleanup confirmation received. Starting file upload.");
                    UART.getConnection()?.removeListener('data', onDataCleanup); // Remove listener
                    sendNewItemFiles(); // Start sending files
                 }
            }

            // Add listener *before* sending command
            UART.getConnection()?.on('data', onDataCleanup);

			// Send cleanup command
			UART.write(cleanupCode.trim() + '\n')
                .then(() => {
                    cleanupSent = true;
                    console.log("Cleanup command sent. Waiting briefly for confirmation or timeout...");
                     // Add a safety timeout in case CLEANUP_DONE is never received
                     setTimeout(() => {
                        if (!cleanupConfirmed) {
                             console.warn("Timeout waiting for CLEANUP_DONE confirmation. Proceeding with upload anyway.");
                             UART.getConnection()?.removeListener('data', onDataCleanup); // Remove listener
                             sendNewItemFiles(); // Attempt upload even without confirmation
                        }
                     }, 3000); // 3-second timeout for confirmation
                })
                .catch((err) => {
                    console.error("Error sending cleanup command:", err);
                    alert("Error sending cleanup command. Aborting upload.");
                    UART.getConnection()?.removeListener('data', onDataCleanup); // Remove listener on error
                    uploadBtn.disabled = false; // Re-enable button
                    uploadBtn.textContent = "Upload to Device";
                });
		}

		// --- Helper function to generate and send files ---
        // (Unchanged from previous successful version)
		function sendNewItemFiles() {
			// Ensure this isn't called multiple times if cleanup confirmation arrives late after timeout
            if (document.getElementById('btnUploadUSB').textContent !== "Uploading...") {
                 console.log("Upload already completed or aborted, skipping sendNewItemFiles.");
                 return;
            }
            console.log("Generating and sending new item files to DATA/ directory...");

			const filesToSend = [];
			const CHUNK_SIZE = 9;
			const pageCounts = [];
			const uploadBtn = document.getElementById('btnUploadUSB');

			for (let i = 0; i < items.length; i += CHUNK_SIZE) {
				const pageIndex = Math.floor(i / CHUNK_SIZE);
				const chunk = items.slice(i, i + CHUNK_SIZE);
				pageCounts.push(chunk.length);
				filesToSend.push({
					name: `DATA/items_${pageIndex}.json`,
					content: JSON.stringify(chunk, null, 2)
				});
			}

			const meta = {
				totalItems: items.length,
				pageCounts: pageCounts
			};
			filesToSend.push({
				name: 'DATA/items_meta.json',
				content: JSON.stringify(meta, null, 2)
			});

			console.log(`Ready to send ${filesToSend.length} files to DATA/ directory.`);

			function sendFile(index) {
				if (index >= filesToSend.length) {
					console.log("All files sent successfully!");
					//alert("All item files have been sent to the DATA/ directory on the device.");
					uploadBtn.disabled = false;
					uploadBtn.textContent = "Upload to Device";
					
					console.log("Sending reboot command...");
                    UART.write("E.reboot()\n")
                    .then(() => console.log("Reboot command sent."))
                    .catch(err => console.error("Error sending reboot command:", err));
					
					return;
				}

				const file = filesToSend[index];
				console.log(`Sending ${file.name}...`);
				// Ensure writeFileSync command is correct
                const command = `try { require('fs').writeFileSync(${JSON.stringify(file.name)}, ${JSON.stringify(file.content)}); } catch(e) { console.log("Write Error:", e); }\n`;


				UART.write(command)
					.then(() => {
						console.log(`Successfully sent command to write ${file.name}.`);
						// Add a slightly longer delay to allow file system operations
						setTimeout(() => sendFile(index + 1), 100);
					})
					.catch((err) => {
						console.log(`Error sending write command for ${file.name}: ${err}`);
						alert(`An error occurred while sending ${file.name}. Aborting.`);
						uploadBtn.disabled = false;
						uploadBtn.textContent = "Upload to Device";
					});
			}
			sendFile(0); // Start sending the first file
		}

        // --- Load items from Device function ---
        async function loadItemsFromDevice() {
            if (!UART.isConnected()) {
                alert("Please connect to a USB device first.");
                return;
            }

            const loadBtn = document.getElementById('btnLoadFromDevice');
            loadBtn.disabled = true;
            loadBtn.textContent = "Loading from Device...";
            console.log("Attempting to load items from device using items_meta.json...");

            let allItems = [];
            const dataDir = 'DATA/';
            const metaFileName = dataDir + 'items_meta.json';
            let metaData;

            // --- Helper to send command and wait for specific response ---
            function sendCommandAndWait(command, endMarker, timeout = 7000) {
                return new Promise((resolve, reject) => {
                    let currentCommandResponse = "";
                    let dataListenerTimeout;

                    function onDataRead(data) {
                        currentCommandResponse += data;
                        // console.log("Raw Read chunk: " + data); // Verbose log if needed

                        const markerIndex = currentCommandResponse.indexOf(endMarker);
                        if (markerIndex !== -1) {
                            if (dataListenerTimeout) clearTimeout(dataListenerTimeout);
                            UART.getConnection()?.removeListener('data', onDataRead);

                            let relevantResponse = currentCommandResponse.substring(0, markerIndex);

                            // **FIXED**: More robust cleaning for echo and prompts
                            const lines = relevantResponse.split(/[\r\n]+/); // Split by newline characters
                            let jsonStartIndex = -1;

                            // Find the first line that looks like the start of JSON ({ or [)
                            for(let i = 0; i < lines.length; i++) {
                                const trimmedLine = lines[i].trim();
                                if (trimmedLine.startsWith('{') || trimmedLine.startsWith('[')) {
                                     // Assume JSON starts here, join this and subsequent lines
                                     jsonStartIndex = i;
                                     break;
                                }
                            }

                            if (jsonStartIndex !== -1) {
                                relevantResponse = lines.slice(jsonStartIndex).join('\n').trim();
                            } else {
                                // If no JSON start found, check for error markers among non-prompt lines
                                const cleanLines = lines.filter(line => {
                                    const trimmedLine = line.trim();
                                    return !trimmedLine.startsWith('>') && trimmedLine !== '=undefined' && trimmedLine !== '';
                                });
                                relevantResponse = cleanLines.join('\n').trim(); // Join remaining lines
                            }

                            console.log(`Cleaned response (before marker ${endMarker}): '${relevantResponse}'`);

                            // Check for error markers *after* cleaning attempt
                            if (relevantResponse === "READ_ERROR_NO_FILE" || relevantResponse === "READ_ERROR") {
                               console.log(`Received error marker: ${relevantResponse}`);
                               resolve(relevantResponse);
                            } else if (relevantResponse === "undefined") {
                                console.log(`Received 'undefined' after cleaning, treating as file not found.`);
                                resolve("READ_ERROR_NO_FILE");
                            } else if (!relevantResponse.startsWith('{') && !relevantResponse.startsWith('[')) {
                                // If after cleaning it STILL doesn't look like JSON, treat as error or non-existent
                                console.log(`Cleaned response doesn't look like JSON. Treating as file not found or error.`);
                                resolve("READ_ERROR_NO_FILE"); // Or READ_ERROR depending on desired behavior
                            }
                            else {
                               resolve(relevantResponse); // Assume valid content
                            }
                        }

                        // Buffer management (increased size)
                        if (currentCommandResponse.length > 200000) { // Allow larger buffer for potentially large files
                            console.warn("Read buffer large, clearing partially.");
                            currentCommandResponse = currentCommandResponse.slice(-1000); // Keep more of the end
                        }
                    }

                    const connection = UART.getConnection();
                    if (!connection) {
                       if (dataListenerTimeout) clearTimeout(dataListenerTimeout);
                       UART.getConnection()?.removeListener('data', onDataRead);
                       return reject("Device disconnected during read operation.");
                    }
                    connection.removeListener('data', onDataRead); // Clear before adding
                    connection.on('data', onDataRead);

                    dataListenerTimeout = setTimeout(() => {
                        UART.getConnection()?.removeListener('data', onDataRead);
                        console.error(`Timeout waiting for response marker: ${endMarker}. Buffer (last 500): ${currentCommandResponse.slice(-500)}`);
                        reject(`Timeout waiting for response marker: ${endMarker}`);
                    }, timeout);

                    // Simplified device-side logic using ternary operator
                    const readCommand = `
                        var c = require('fs').readFileSync(${JSON.stringify(command)});
                        print(c===undefined?"READ_ERROR_NO_FILE":c, ${JSON.stringify(endMarker)});
                    \n`;

                    UART.write(readCommand)
                        .then(() => console.log(`Sent command to read: ${command}`))
                        .catch((err) => {
                            if (dataListenerTimeout) clearTimeout(dataListenerTimeout);
                            UART.getConnection()?.removeListener('data', onDataRead);
                            reject(`Error sending read command for ${command}: ${err}`);
                        });
                });
            }


            // --- Main Logic ---
            try {
                // 1. Read Meta File
                console.log("Reading meta file:", metaFileName);
                const metaEndMarker = "__META_END__";
                const metaFileContent = await sendCommandAndWait(metaFileName, metaEndMarker);

                if (metaFileContent === "READ_ERROR_NO_FILE") {
                    throw new Error(`Meta file (${metaFileName}) not found on the device. Cannot load items.`);
                }
                if (metaFileContent === "READ_ERROR") {
                     throw new Error(`Error reading meta file (${metaFileName}) on the device.`);
                }

                // 2. Parse Meta File
                try {
                    metaData = JSON.parse(metaFileContent);
                    console.log("Parsed Meta Data:", metaData);
                    if (!metaData || !Array.isArray(metaData.pageCounts)) {
                        throw new Error("Invalid meta file format. Missing 'pageCounts' array.");
                    }
                } catch (e) {
                    console.error("Error parsing meta file content:", metaFileContent);
                    // Throw a more specific error including the problematic content
                    throw new Error(`Failed to parse ${metaFileName} from device. Content received after cleaning: '${metaFileContent}'. Error: ${e.message}`);
                }

                // 3. Read Item Files Based on Meta Data
                const numPages = metaData.pageCounts.length;
                console.log(`Meta file indicates ${numPages} item page(s) to read.`);

                if (numPages === 0) {
                    console.log("Meta file indicates 0 pages. No item files to load.");
                } else {
                    for (let i = 0; i < numPages; i++) {
                        const itemFileName = `${dataDir}items_${i}.json`;
                        const endMarker = `__ITEMS_${i}_END__`;
                        console.log(`Attempting to read item file: ${itemFileName}`);

                        try {
                            const itemFileContent = await sendCommandAndWait(itemFileName, endMarker);

                            if (itemFileContent === "READ_ERROR_NO_FILE") {
                                console.warn(`Meta file listed ${itemFileName}, but it was not found on device. Skipping.`);
                                continue;
                            }
                            if (itemFileContent === "READ_ERROR") {
                                console.warn(`Error reading ${itemFileName} (though listed in meta). Skipping.`);
                                continue;
                            }

                            // Try parsing the content
                            try {
                                if (itemFileContent === "") {
                                    console.log(`File ${itemFileName} is empty. Skipping parse.`);
                                } else {
                                    const pageItems = JSON.parse(itemFileContent);
                                    if (Array.isArray(pageItems)) {
                                        allItems.push(...pageItems);
                                        console.log(`Successfully parsed ${pageItems.length} items from ${itemFileName}`);
                                    } else {
                                        console.warn(`File ${itemFileName} did not contain a valid JSON array after cleaning. Content: '${itemFileContent}'. Skipping.`);
                                    }
                                }
                            } catch (e) {
                                console.warn(`Failed to parse ${itemFileName} after cleaning. Content: '${itemFileContent}'. Skipping. Error: ${e}`);
                            }

                        } catch (error) { // Catch errors from sendCommandAndWait
                            console.error(`Error during read attempt for ${itemFileName}:`, error);
                            throw new Error(`Communication error while reading ${itemFileName}: ${error.message || error}`);
                        }
                    } // End for loop
                } // End else (numPages > 0)

                // 4. Update UI
                console.log(`Total items loaded from device: ${allItems.length}`);
                //alert(`Successfully loaded ${allItems.length} items from the device.`);

                items = allItems;
                currentIndex = -1;
                renderItemList();
                if (items.length > 0) {
                    selectItem(0);
                } else {
                    document.getElementById('editor').innerHTML = `<div class="empty-state"><h2>No items loaded</h2><p>Item files were read, but contained no valid items, or meta file indicated zero pages.</p></div>`;
                    renderPipboyPreview();
                }

                const hasItems = items.length > 0;
                document.getElementById('exportBtnHeader').disabled = !hasItems;
                document.getElementById('btnUploadUSB').disabled = !(UART.isConnected() && hasItems); // Check connection too


            } catch (error) { // Catch errors from reading/parsing meta or communication errors in loop
                console.error("Error loading items from device:", error);
                alert("Error loading items from device: " + error.message);
                 items = [];
                 currentIndex = -1;
                 renderItemList();
                 document.getElementById('editor').innerHTML = `<div class="empty-state"><h2>Load Failed</h2><p>${error.message}</p></div>`;
                 renderPipboyPreview();
                 document.getElementById('exportBtnHeader').disabled = true;
    			 document.getElementById('btnUploadUSB').disabled = true;

            } finally {
                loadBtn.disabled = false;
                loadBtn.textContent = "Load Items from Device";
            }
        }


		// --- START of previously omitted functions ---
		function initializePresets() {
			const allPresets = [];
			if (typeof consumablePresets !== 'undefined') allPresets.push(...consumablePresets);
			if (typeof weaponPresets !== 'undefined') allPresets.push(...weaponPresets);
			if (typeof apparelPresets !== 'undefined') allPresets.push(...apparelPresets);
			const combined = {};
			allPresets.forEach(item => {
				const key = item.name.toLowerCase().replace(/\s+/g, '');
				combined[key] = item;
			});
			presetItems = combined;
		}

		function renderPresetDropdown() {
			const dropdown = document.getElementById('presetDropdown');
			let optionsHtml = `<option value="">Add Preset Item...</option>`;
			for (const key in presetItems) {
				optionsHtml += `<option value="${key}">${presetItems[key].name}</option>`;
			}
			dropdown.innerHTML = optionsHtml;
		}

		function readFileAsText(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = () => reject(reader.error);
				reader.readAsText(file);
			});
		}

		async function loadItemsFromFiles(event) {
			const files = event.target.files;
			if (!files.length) return;

			let loadedItems = [];
			for (const file of files) {
				try {
					const fileContent = await readFileAsText(file);
					const parsedJson = JSON.parse(fileContent);
					if (Array.isArray(parsedJson)) {
						loadedItems.push(...parsedJson);
					} else {
						alert(`Warning: File ${file.name} is not a valid item array and was skipped.`);
					}
				} catch (error) {
					console.error(`Error reading or parsing file ${file.name}:`, error);
					alert(`Could not load file: ${file.name}. It may not be a valid JSON file.`);
				}
			}
			items = loadedItems;
			currentIndex = -1; // Reset selection
			renderItemList();
			if (items.length > 0) {
				selectItem(0); // Select the first new item
			} else {
				// Clear UI if no items were loaded
				document.getElementById('editor').innerHTML = `<div class="empty-state"><h2>No item selected</h2><p>Select an item from the list or create a new one</p></div>`;
				renderPipboyPreview();
			}

			// Enable/disable buttons based on whether items exist
			const hasItems = items.length > 0;
			document.getElementById('exportBtnHeader').disabled = !hasItems;
			// Only enable upload if connected AND has items
            document.getElementById('btnUploadUSB').disabled = !(UART.isConnected() && hasItems);


			// Clear the file input value to allow loading the same file again
			event.target.value = '';
		}

		function loadDataFolder(event) {
			const files = event.target.files;
			if (files.length === 0) return;
			const soundFiles = [],
				imageFiles = [];
			for (const file of files) {
				const fileName = file.name;
                const relativePath = file.webkitRelativePath || file.name;
				if (relativePath.toLowerCase().endsWith('.wav') && !relativePath.includes('EquipUp') && !relativePath.includes('EquipDown')) {
					soundFiles.push(fileName);
				}
				if (relativePath.toLowerCase().endsWith('.js')) {
					imageFiles.push(fileName);
				}
			}
			availableSounds = soundFiles.sort();
			availableImages = imageFiles.sort();
			if (currentIndex > -1) {
				renderEditor();
			}
             console.log("Loaded available sounds:", availableSounds);
             console.log("Loaded available images:", availableImages);
		}


		function renderItemList() {
			const list = document.getElementById('itemList');
			list.innerHTML = '';
			items.forEach((item, index) => {
				const li = document.createElement('li');
				li.className = index === currentIndex ? 'active' : '';
				const isFirst = index === 0;
				const isLast = index === items.length - 1;
				li.innerHTML = `
            <div class="item-name-wrapper"> <span class="item-name">${item.name || 'Unnamed Item'}</span> </div>
            ${item.type ? `<span class="item-type">${item.type}</span>` : ''}
            <div class="reorder-arrows">
                <button onclick="moveItemUp(${index}, event)" ${isFirst ? 'disabled' : ''}>▲</button>
                <button onclick="moveItemDown(${index}, event)" ${isLast ? 'disabled' : ''}>▼</button>
            </div>
            <button class="delete-btn" onclick="deleteItem(${index}, event)">×</button>
        `;
				li.onclick = (event) => {
					if (event.target.closest('button, .reorder-arrows')) return;
					selectItem(index);
				};
				list.appendChild(li);
			});
		}

		function renderPipboyPreview() {
			const item = items[currentIndex];
			const previewName = document.getElementById('preview-name');
			const previewQty = document.getElementById('preview-qty');
			const statsList = document.getElementById('preview-stats-list');
			if (!item) {
				previewName.textContent = 'ITEM NAME';
				previewQty.textContent = '0';
				statsList.innerHTML = '';
				return;
			}
			previewName.textContent = (item.name || 'NO NAME').toUpperCase();
			previewQty.textContent = item.quantity || 0;
			statsList.innerHTML = '';
			const createStatValueRow = (label, value) => {
				const row = document.createElement('div');
				row.className = 'stat-row';
				row.innerHTML = `<span class="stat-name">${label.toUpperCase()}</span><span class="stat-value bright-bg" style="padding: 0 4px;">${value}</span>`;
				statsList.appendChild(row);
			};
			if (item.damages && item.damages.length > 0) {
				item.damages.forEach(d => createStatValueRow(d.type || '?', d.value || '?'));
			}
			if (item.defenses && item.defenses.length > 0) {
				item.defenses.forEach(d => createStatValueRow(d.type || '?', d.value || '?'));
			}
			if (item.stats) {
				for (const statName in item.stats) {
					const row = document.createElement('div');
					const statData = item.stats[statName];
					const isObject = typeof statData === 'object' && statData !== null;
					const value = isObject ? statData.value : statData;
					const isTimed = isObject && statData.isTimed;
					let backgroundClass = (statName === item.ammoType) ? 'bright-bg' : 'dithered-bg';
					row.className = `stat-row ${backgroundClass}`;
					const timeIndicator = isTimed ? '(T) ' : '';
					row.innerHTML = `<span class="stat-name">${statName.toUpperCase()}</span><span class="stat-value">${timeIndicator}${value}</span>`;
					statsList.appendChild(row);
				}
			}
		}

		function selectItem(index) {
			currentIndex = index;
			renderItemList();
			renderEditor();
			renderPipboyPreview();
		}

		function updateItem(field, value) {
			if (currentIndex < 0) return;
			items[currentIndex][field] = value;
			if (field === 'name' || field === 'quantity' || field === 'type') {
				renderItemList();
			}
             if (field === 'type') {
                 renderEditor(); // Re-render editor if type changes
             }
			renderPipboyPreview();
		}

		function moveItem(fromIndex, toIndex) {
			if (fromIndex < 0 || fromIndex >= items.length || toIndex < 0 || toIndex >= items.length) return;
			const [item] = items.splice(fromIndex, 1);
			items.splice(toIndex, 0, item);
			selectItem(toIndex);
		}

		function moveItemUp(index, event) {
			event.stopPropagation();
			moveItem(index, index - 1);
		}

		function moveItemDown(index, event) {
			event.stopPropagation();
			moveItem(index, index + 1);
		}

		function moveStat(key, direction) {
			if (currentIndex < 0 || !items[currentIndex].stats) return;
			const stats = items[currentIndex].stats;
			const statsArray = Object.entries(stats);
			const fromIndex = statsArray.findIndex(pair => pair[0] === key);
			const toIndex = fromIndex + direction;

			if (fromIndex < 0 || toIndex < 0 || toIndex >= statsArray.length) return;

			[statsArray[fromIndex], statsArray[toIndex]] = [statsArray[toIndex], statsArray[fromIndex]];

			items[currentIndex].stats = Object.fromEntries(statsArray);
			renderStats();
			renderPipboyPreview();
		}

		function moveStatUp(key) {
			moveStat(key, -1);
		}

		function moveStatDown(key) {
			moveStat(key, 1);
		}

		function addDamage() {
			if (currentIndex < 0 || items[currentIndex].type !== 'weapon') return;
			if (!items[currentIndex].damages) {
				items[currentIndex].damages = [];
			}
			items[currentIndex].damages.push({ type: "attack", value: "10" });
			renderDamages();
			renderPipboyPreview();
		}

		function removeDamage(index) {
			if (currentIndex < 0 || !items[currentIndex].damages) return;
			items[currentIndex].damages.splice(index, 1);
			if (items[currentIndex].damages.length === 0) {
				delete items[currentIndex].damages;
			}
			renderDamages();
			renderPipboyPreview();
		}

		function addDefense() {
			if (currentIndex < 0 || items[currentIndex].type !== 'apparel') return;
			if (!items[currentIndex].defenses) {
				items[currentIndex].defenses = [];
			}
			items[currentIndex].defenses.push({ type: "defense", value: "10" });
			renderDefenses();
			renderPipboyPreview();
		}

		function removeDefense(index) {
			if (currentIndex < 0 || !items[currentIndex].defenses) return;
			items[currentIndex].defenses.splice(index, 1);
			if (items[currentIndex].defenses.length === 0) {
				delete items[currentIndex].defenses;
			}
			renderDefenses();
			renderPipboyPreview();
		}

		function addStat() {
			if (currentIndex < 0) return;
			if (!items[currentIndex].stats) {
				items[currentIndex].stats = {};
			}
			let newKey = "NewStat", counter = 1;
			while (items[currentIndex].stats.hasOwnProperty(newKey)) {
				newKey = `NewStat${counter++}`;
			}
			items[currentIndex].stats[newKey] = "0";
			renderStats();
			renderPipboyPreview();
		}

		function removeStat(key) {
			if (currentIndex < 0 || !items[currentIndex].stats) return;
			delete items[currentIndex].stats[key];
			renderStats();
			renderPipboyPreview();
		}

		function updateStatKey(oldKey, newKey) {
            if (currentIndex < 0 || !items[currentIndex].stats || oldKey === newKey || !newKey) return;
             if (items[currentIndex].stats.hasOwnProperty(newKey)) {
                 alert(`Stat key "${newKey}" already exists!`);
                 renderStats(); // Re-render to show original key
                 return;
            }
            // Create a new object with the desired order (or close to it)
            const oldStats = items[currentIndex].stats;
            const newStats = {};
            for (const key in oldStats) {
                if (key === oldKey) {
                    newStats[newKey] = oldStats[oldKey]; // Add with new key
                } else {
                    newStats[key] = oldStats[key]; // Keep existing
                }
            }
            items[currentIndex].stats = newStats; // Replace the stats object

            renderStats();
            renderPipboyPreview();
        }

		function updateStatValue(key, value) {
			if (currentIndex < 0 || !items[currentIndex].stats) return;
			const stat = items[currentIndex].stats[key];
			if (typeof stat === 'object' && stat !== null && stat.hasOwnProperty('isTimed')) {
				stat.value = value;
			} else {
				items[currentIndex].stats[key] = value;
			}
			renderPipboyPreview();
		}

		function toggleStatIsTimed(key, isChecked) {
			if (currentIndex < 0 || !items[currentIndex].stats) return;
            const currentItem = items[currentIndex];
            if (currentItem.type !== 'consumable') return;

			const currentStat = currentItem.stats[key];
            const currentValue = (typeof currentStat === 'object' && currentStat !== null) ? currentStat.value : currentStat;

			if (isChecked) {
				currentItem.stats[key] = { value: currentValue || "0", isTimed: true };
			} else {
				currentItem.stats[key] = currentValue;
			}
			renderStats();
			renderPipboyPreview();
		}

		function updateDamage(index, field, value) {
			if (currentIndex < 0 || !items[currentIndex].damages || !items[currentIndex].damages[index]) return;
			items[currentIndex].damages[index][field] = value;
			renderPipboyPreview();
		}

		function updateDefense(index, field, value) {
			if (currentIndex < 0 || !items[currentIndex].defenses || !items[currentIndex].defenses[index]) return;
			items[currentIndex].defenses[index][field] = value;
			renderPipboyPreview();
		}

		function addBaseItem(type) {
			const CappedType = type.charAt(0).toUpperCase() + type.slice(1);
			let baseItem = {
				name: `New ${CappedType}`, type: type, quantity: 1, effect: "",
				stats: { Weight: "1.0", Value: "10" }
			};
			switch (type) {
				case 'weapon':
					baseItem.damages = [{ type: "attack", value: "5" }];
					baseItem.ammoType = "None";
					baseItem.stats["Fire Rate"] = "10"; baseItem.stats.Range = "50"; break;
				case 'apparel':
					baseItem.defenses = [{ type: "defense", value: "5" }];
					baseItem.equipSlots = []; break;
				case 'consumable': baseItem.stats.Health = "10"; break;
			}
			items.push(baseItem);
			selectItem(items.length - 1);
			document.getElementById('exportBtnHeader').disabled = false;
			if (UART.isConnected()) document.getElementById('btnUploadUSB').disabled = false;
		}

		function addPresetItem(presetKey) {
			if (!presetKey || !presetItems[presetKey]) return;
			const preset = presetItems[presetKey];
			const newItem = JSON.parse(JSON.stringify(preset)); // Deep copy
			items.push(newItem);
			selectItem(items.length - 1);
			document.getElementById('exportBtnHeader').disabled = false;
            if (UART.isConnected()) document.getElementById('btnUploadUSB').disabled = false;
		}

		function deleteItem(index, event) {
			event.stopPropagation();
            if (index < 0 || index >= items.length) return;
             if (!confirm(`Are you sure you want to delete "${items[index].name}"?`)) return;

			items.splice(index, 1);
            let newIndex = -1;
            if (items.length > 0) {
                 if (index >= items.length) newIndex = items.length - 1;
                 else if (currentIndex === index) newIndex = Math.max(0, index - 1);
                 else if (index < currentIndex) newIndex = currentIndex - 1;
                 else newIndex = currentIndex;
            }

			renderItemList();
            if (newIndex > -1) { selectItem(newIndex); }
            else {
                currentIndex = -1;
				document.getElementById('editor').innerHTML = `<div class="empty-state"><h2>No item selected</h2><p>Select an item from the list or create a new one</p></div>`;
				renderPipboyPreview();
            }
			const hasItems = items.length > 0;
			document.getElementById('exportBtnHeader').disabled = !hasItems;
			document.getElementById('btnUploadUSB').disabled = !(UART.isConnected() && hasItems);
		}

		function addSound(sound) {
			if (!sound || currentIndex < 0) return;
			if (!items[currentIndex].sounds) items[currentIndex].sounds = [];
			if (!items[currentIndex].sounds.includes(sound)) {
				items[currentIndex].sounds.push(sound); renderSounds();
			}
		}

		function removeSound(index) {
			if (currentIndex < 0 || !items[currentIndex].sounds || index < 0 || index >= items[currentIndex].sounds.length) return;
			items[currentIndex].sounds.splice(index, 1);
			if (items[currentIndex].sounds.length === 0) delete items[currentIndex].sounds;
			renderSounds();
		}

		function addApparelEquipSlot(slot) {
			if (!slot || currentIndex < 0 || items[currentIndex].type !== 'apparel') return;
			if (!items[currentIndex].equipSlots) items[currentIndex].equipSlots = [];
			if (!items[currentIndex].equipSlots.includes(slot)) {
				items[currentIndex].equipSlots.push(slot); renderApparelEquipSlots();
			}
		}

		function removeApparelEquipSlot(index) {
			if (currentIndex < 0 || !items[currentIndex].equipSlots || index < 0 || index >= items[currentIndex].equipSlots.length) return;
			items[currentIndex].equipSlots.splice(index, 1);
			if (items[currentIndex].equipSlots.length === 0) delete items[currentIndex].equipSlots;
			renderApparelEquipSlots();
		}

		function renderEditor() {
			if (currentIndex < 0) {
				document.getElementById('editor').innerHTML = `<div class="empty-state"><h2>No item selected</h2><p>Select an item from the list or create a new one</p></div>`; return;
			}
			const item = items[currentIndex];
			let html = `<div class="section-header">Edit Item</div>`;
			html += `
                <div class="form-row">
                  <div class="form-group"><label>Type</label><select onchange="updateItem('type', this.value)"><option value="" ${!item.type ? 'selected' : ''}>None</option><option value="weapon" ${item.type === 'weapon' ? 'selected' : ''}>Weapon</option><option value="apparel" ${item.type === 'apparel' ? 'selected' : ''}>Apparel</option><option value="consumable" ${item.type === 'consumable' ? 'selected' : ''}>Consumable</option></select></div>
                  <div class="form-group"><label>Name</label><input type="text" value="${item.name || ''}" oninput="updateItem('name', this.value)"></div>
                </div>
                <div class="form-row">
                  <div class="form-group"><label>Quantity</label><input type="number" value="${item.quantity || 1}" min="0" step="1" oninput="updateItem('quantity', parseInt(this.value) || 0)"></div>
                  <div class="form-group"><label>Sounds</label><select onchange="addSound(this.value); this.value='';"><option value="">Select a sound file...</option>${availableSounds.map(s => `<option value="${s}">${s}</option>`).join('')}</select><div class="sound-list" id="soundList"></div></div>
                </div>
                <div class="form-group"><label>Image File</label><select onchange="updateItem('image', this.value)"><option value="">None</option>${availableImages.map(img => `<option value="${img}" ${item.image === img ? 'selected' : ''}>${img}</option>`).join('')}</select></div>`;
			if (item.type === 'weapon') {
				html += `<div class="form-group"><label>Ammo Type</label><input type="text" value="${item.ammoType || 'None'}" oninput="updateItem('ammoType', this.value || null)" placeholder="e.g., Fusion Cell or None"></div><div class="form-group"><label>Damage Values</label><div class="damages-container" id="damagesContainer"></div><button class="add-stat-btn" onclick="addDamage()">+ Add Damage Type</button></div>`;
			}
			if (item.type === 'apparel') {
				html += `<div class="form-group"><label>Equip Slots</label><select onchange="addApparelEquipSlot(this.value); this.value='';"><option value="">Add an equip slot...</option>${apparelEquipSlots.map(st => `<option value="${st}">${st}</option>`).join('')}</select><div class="equip-slot-list" id="equipSlotList"></div></div><div class="form-group"><label>Defense Values</label><div class="defenses-container" id="defensesContainer"></div><button class="add-stat-btn" onclick="addDefense()">+ Add Defense Type</button></div>`;
			}
			html += `<div class="form-group" style="margin-top: 15px;"><label>Stats</label><div class="stats-container" id="statsContainer"></div><button class="add-stat-btn" onclick="addStat()">+ Add Stat</button></div><div class="form-group"><label>Effect Description</label><textarea oninput="updateItem('effect', this.value)">${item.effect || ''}</textarea></div>`;
			document.getElementById('editor').innerHTML = html;
			renderDamages(); renderDefenses(); renderSounds(); renderApparelEquipSlots(); renderStats();
		}

		function renderDamages() {
            const container = document.getElementById('damagesContainer'); if (!container) return; container.innerHTML = ''; if (currentIndex < 0 || !items[currentIndex].damages) return;
			items[currentIndex].damages.forEach((damage, index) => {
				const div = document.createElement('div'); div.className = 'damage-item';
				div.innerHTML = `<div><label>Type</label><select onchange="updateDamage(${index}, 'type', this.value)">${damageTypes.map(t => `<option value="${t}" ${damage.type === t ? 'selected' : ''}>${t}</option>`).join('')}</select></div><div><label>Value</label><input type="text" value="${damage.value || ''}" oninput="updateDamage(${index}, 'value', this.value)"></div><button class="remove-stat-btn" onclick="removeDamage(${index})">Remove</button>`;
				container.appendChild(div);
			});
		}

		function renderDefenses() {
            const container = document.getElementById('defensesContainer'); if (!container) return; container.innerHTML = ''; if (currentIndex < 0 || !items[currentIndex].defenses) return;
			items[currentIndex].defenses.forEach((defense, index) => {
				const div = document.createElement('div'); div.className = 'defense-item';
				div.innerHTML = `<div><label>Type</label><select onchange="updateDefense(${index}, 'type', this.value)">${defenseTypes.map(t => `<option value="${t}" ${defense.type === t ? 'selected' : ''}>${t}</option>`).join('')}</select></div><div><label>Value</label><input type="text" value="${defense.value || ''}" oninput="updateDefense(${index}, 'value', this.value)"></div><button class="remove-stat-btn" onclick="removeDefense(${index})">Remove</button>`;
				container.appendChild(div);
			});
		}

		function renderSounds() {
			const container = document.getElementById('soundList'); if (!container) return; container.innerHTML = ''; if (currentIndex < 0 || !items[currentIndex].sounds) return;
			items[currentIndex].sounds.forEach((sound, index) => {
				const tag = document.createElement('div'); tag.className = 'sound-tag'; tag.innerHTML = `${sound} <button onclick="removeSound(${index})">×</button>`; container.appendChild(tag);
			});
		}

		function renderApparelEquipSlots() {
			const container = document.getElementById('equipSlotList'); if (!container) return; container.innerHTML = ''; if (currentIndex < 0 || !items[currentIndex].equipSlots) return;
			items[currentIndex].equipSlots.forEach((slot, index) => {
				const tag = document.createElement('div'); tag.className = 'equip-slot-tag'; tag.innerHTML = `${slot} <button onclick="removeApparelEquipSlot(${index})">×</button>`; container.appendChild(tag);
			});
		}

		function renderStats() {
			const container = document.getElementById('statsContainer'); if (!container) return; container.innerHTML = ''; if (currentIndex < 0 || !items[currentIndex].stats) return;
			const item = items[currentIndex]; const statsArray = Object.entries(item.stats);
			statsArray.forEach(([key, statData], index) => {
				const isObject = typeof statData === 'object' && statData !== null && statData.hasOwnProperty('isTimed');
				const value = isObject ? statData.value : statData; const isTimed = isObject && statData.isTimed;
				const isFirst = index === 0; const isLast = index === statsArray.length - 1;
				const div = document.createElement('div'); let timedCheckboxHtml = '';
				if (item.type === 'consumable') {
					div.className = 'stat-item consumable-stat';
					timedCheckboxHtml = `<div class="checkbox-group"><input type="checkbox" id="timed_${key}" ${isTimed ? 'checked' : ''} onchange="toggleStatIsTimed('${key}', this.checked)"><label for="timed_${key}">Timed</label></div>`;
				} else { div.className = 'stat-item'; }
				div.innerHTML = `<div><label>Stat Name</label><input type="text" value="${key}" onchange="updateStatKey('${key}', this.value)"></div><div><label>Value</label><input type="text" value="${value || ''}" oninput="updateStatValue('${key}', this.value)"></div>${timedCheckboxHtml}<div class="reorder-arrows"><button onclick="moveStatUp('${key}')" ${isFirst ? 'disabled' : ''}>▲</button><button onclick="moveStatDown('${key}')" ${isLast ? 'disabled' : ''}>▼</button></div><button class="remove-stat-btn" onclick="removeStat('${key}')">Remove</button>`;
				container.appendChild(div);
			});
		}

		function exportJSON() {
            if (items.length === 0) { alert("No items to export!"); return; }
			const zip = new JSZip(); const CHUNK_SIZE = 9; const pageCounts = [];
			for (let i = 0; i < items.length; i += CHUNK_SIZE) {
				const pageIndex = Math.floor(i / CHUNK_SIZE); const chunk = items.slice(i, i + CHUNK_SIZE); pageCounts.push(chunk.length);
				zip.file(`items_${pageIndex}.json`, JSON.stringify(chunk, null, 2), { date: new Date(), compression: "DEFLATE" });
			}
			const meta = { totalItems: items.length, pageCounts: pageCounts };
			zip.file('items_meta.json', JSON.stringify(meta, null, 2), { date: new Date(), compression: "DEFLATE" });
			zip.generateAsync({ type: 'blob', compression: "DEFLATE", compressionOptions: { level: 6 } })
                .then(content => {
                    const url = URL.createObjectURL(content); const a = document.createElement('a'); a.href = url; a.download = 'items_export.zip';
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                }).catch(err => { console.error("Error generating ZIP:", err); alert("Error generating ZIP."); });
		}
		// --- END of previously omitted functions ---

		// --- Initial setup ---
		window.onload = () => {
			// Configure UART ports *after* UART object is guaranteed to exist
            if (typeof UART !== "undefined") {
                UART.ports = ["Web Serial"];
            } else {
                console.error("UART object not found during window.onload configuration.");
                alert("Error: Failed to load UART library properly. Connection may not work.");
            }

			initializePresets();
			renderPresetDropdown();
			renderItemList();
			renderPipboyPreview();

			const hasItems = items.length > 0;
			document.getElementById('exportBtnHeader').disabled = !hasItems;
			document.getElementById('btnUploadUSB').disabled = true; // Start disabled
            document.getElementById('btnLoadFromDevice').disabled = true; // Start disabled


			// Connection Button Logic
			let connectButton = document.getElementById("btnConnectUSB");
			let uploadButton = document.getElementById("btnUploadUSB");
			let loadFromDeviceButton = document.getElementById("btnLoadFromDevice");
			let currentConnection = null;

			if (connectButton) {
				connectButton.addEventListener("click", function() {
                    if (typeof UART === "undefined") {
						alert("Error: UART library (uart.js) not loaded. Check file path in <head>.");
						return;
					}

					if (UART.isConnected()) {
						UART.close(); // Triggers the 'close' event handler below
						return;
					}

					connectButton.textContent = "Connecting...";
					connectButton.disabled = true;
                    if (uploadButton) uploadButton.disabled = true;
                    if (loadFromDeviceButton) loadFromDeviceButton.disabled = true;

					UART.connectAsync()
						.then(function(connectionInstance) {
                            if (!connectionInstance) {
                                console.log("Connection attempt failed or cancelled by user.");
                                connectButton.textContent = "Connect via USB";
							    connectButton.disabled = false;
                                if (uploadButton) uploadButton.disabled = true;
                                if (loadFromDeviceButton) loadFromDeviceButton.disabled = true;
                                return;
                            }
							currentConnection = connectionInstance;
							console.log("Connected!");
							connectButton.textContent = "Disconnect";
							connectButton.disabled = false;
                            const buttonsShouldBeEnabled = items.length > 0;
                            if (uploadButton) uploadButton.disabled = !buttonsShouldBeEnabled;
                            if (loadFromDeviceButton) loadFromDeviceButton.disabled = false;

							// Attach the close listener
							currentConnection.on('close', function() {
								console.log("Disconnected.");
								connectButton.textContent = "Connect via USB";
								connectButton.disabled = false;
                                if (uploadButton) uploadButton.disabled = true;
                                if (loadFromDeviceButton) loadFromDeviceButton.disabled = true;
								currentConnection = null;
							});
						})
						.catch(function(error) {
							console.log("Connection failed:", error);
                            alert("Connection failed: " + error);
							connectButton.textContent = "Connect via USB";
							connectButton.disabled = false;
                            if (uploadButton) uploadButton.disabled = true;
                            if (loadFromDeviceButton) loadFromDeviceButton.disabled = true;
                            currentConnection = null;
						});
				});
			}
		};
	</script>
</body>

</html>